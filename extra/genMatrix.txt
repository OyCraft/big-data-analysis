

##################################
|                                |
|     有关genMatrix.py的注释      |
|                                |
##################################



概述：genMatrix函数用于模拟生成共现矩阵，以便在没有真实数据情况下调试推荐算法程序。
     如果需要讨论推荐算法的预测能力，真实的数据是必须的，不建议使用本函数。

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

genMatrix变量及调用函数说明：

         输入变量：nUser:    数值，用户数量
                  nItem:    数值，商品数量
                  sLim:     二维数组，表示用户打分分值下限和上限，如[0, 10]
                  sRound:   布尔变量，默认为True，表示打分分值取整。若为False则允许用户给出浮点分数
                  sigma2:   数值，默认为16。用户最终打分服从一个正态分布，sigma2是尺度参数
                  default： 数值，默认为True，表示打分过程中涉及的随机数服从程序默认给定的分布。若为False则要求后续手动输入分布。

         输出变量：score:    nUser*nItem维数值矩阵，即所求共现矩阵

    调用函数genDiscNum说明：
         
        genDiscNum函数能够随机产生[0, 9]范围内的整数。其所服从的离散分布列可以完全手动设定，也可以基于正态分布给出。
        基于正态分布给出时，先输入正态分布参数，程序会计算x={0, 1, 2, ... , 9}时的密度，并保存为pSeries，作为分布列的初值。
        但此时sum(pSeries)!=1，也就是说pSeries还不符合分布列要求。因此程序对其中每个元素乘以(1 / sum(pSeries))以纠正这一点。
        之后，基于已有分布列，程序使用轮盘赌的方式产生所需随机数。

            输入变量：size:     数值，要产生随机数的个数
                     dist:     二维数组或者十维数组：
                               输入二维数组时，程序基于正态分布给出分布列
                               输入十维数组时，程序直接将其作为分布列

            输出变量：ran:      size维数组，即所求随机数

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

genMatrix算法思想：

    每一个用户有两种特征：评分偏好（ua）和购物频繁度（ub），取值均为[0, 9]范围内的整数
    ua越大，用户越喜欢给商品打高分；ub越大，用户越经常购物

    每一个商品也有两种特征：品质（ia）和人气（ib），取值均为[0, 9]范围内的整数
    ia越大，商品质量越好；ib越大，商品越多人购买

    那么，如何随机产生特性不同的用户和商品呢？就是使用前面所述genDiscNum函数。为此，可以给定分布列，也可以把正态分布离散化得到分布列
    程序中，默认对ua和ia使用正态分布N(7, 3)，即假设人们喜欢给较高的分数，商品质量大都较好
        默认对ub使用正态分布N(2, 4)，ib使用正态分布N(3, 3)，即假设多数人购物不是很频繁，多数商品人气不高

    在产生打分时，遍历共现矩阵每一个格子。
    首先，判断是否需要打分。算法认为，每个格子对应的用户ub和商品ib越大，这个格子越可能被打分。
        程序中具体使用的是一个(0, 1)两点分布，值为1时进行打分。打分概率为：(ub + 1)(ib + 1) / 100
        这样给概率赋值，更加容易得到较为稀疏的矩阵。
    其次，给出分数。算法认为，每个格子对应的用户ua和商品ia越大，这个格子越容易得到更高的分数。
        程序中具体使用的是正态分布N((ua + ia) * 5, sigma2)，如果分数大于100则设为100，低于0则设为0

    打分后，分数在[0, 100]上取值，需要根据sLim和sRound放缩、取整，整理成我们想要的分数，比如五分制、十分制。

    最后输出score矩阵前，为了展示更多信息，程序给每行用户命名为：User + 编号 + a + ua的值 + b + ub的值
        并给每列的商品命名为：Item + 编号 + a + ia的值 + b + ib的值

    采用上述算法生成的共现矩阵中，尽管每个格子打分是独立的，但用户之间和商品之间特征存在相似性，特征相近的用户或商品会有相似的分数。









